<template>
  <div id="importXLS">
    <v-snackbar v-model="snackbar" top right timeout="-1">
      <v-card-text>
        {{ message }}
      </v-card-text>
      <template v-slot:action="{ attrs }">
        <v-btn color="pink" text v-bind="attrs" @click="snackbar = false">
          X
        </v-btn>
      </template>
    </v-snackbar>

    <v-container fluid>
      <v-row>
        <v-col cols="2">
          <v-select
            label="Magazyn"
            v-model="IDWarehouse"
            :items="warehouses"
            item-title="Nazwa"
            item-value="IDMagazynu"
            @update:modelValue="clear()"
            hide-details="auto"
          ></v-select>
        </v-col>
        <v-col cols="2" v-if="IDWarehouse">
          <v-file-input
            v-model="files"
            ref="fileupload"
            label="przesyłanie Excel"
            show-size
            truncate-length="24"
            @change="onFileChange"
          ></v-file-input>
        </v-col>
      </v-row>
      <v-progress-linear
        :active="loading"
        indeterminate
        color="purple"
      ></v-progress-linear>
      <v-row v-if="table.length && files">
        <v-col cols="12">
          <p>Loaded {{ table.length }} rows</p>
          <p v-if="table.length > 0">Columns: {{ table[0].length }}</p>
          <div class="d-flex gap-2">
            <v-btn color="primary" @click="makeJson"> Make JSON </v-btn>
            <v-btn
              color="orange"
              @click="validateProducts"
              :disabled="!canValidate || validating"
              :loading="validating"
            >
              Sprawdź produkty
            </v-btn>
            <v-btn
              color="green"
              @click="createDocument"
              :disabled="!canCreateDocument || creating"
              :loading="creating"
            >
              Utwórz dokument DM
            </v-btn>
          </div>
        </v-col>

        <!-- Validation Results -->
        <v-col cols="12" v-if="validationResults">
          <v-card>
            <v-card-title>Wyniki walidacji</v-card-title>
            <v-card-text>
              <div v-if="validationResults.errors.length > 0" class="mb-4">
                <h4 class="text-red">Błędy:</h4>
                <ul>
                  <li
                    v-for="error in validationResults.errors"
                    :key="error"
                    class="text-red"
                  >
                    {{ error }}
                  </li>
                </ul>
              </div>

              <div v-if="validationResults.warnings.length > 0" class="mb-4">
                <h4 class="text-orange">Ostrzeżenia:</h4>
                <ul>
                  <li
                    v-for="warning in validationResults.warnings"
                    :key="warning"
                    class="text-orange"
                  >
                    {{ warning }}
                  </li>
                </ul>
              </div>

              <div class="mb-2">
                <strong>Istniejące produkty:</strong>
                {{ validationResults.existing_products.length }}
              </div>
              <div class="mb-2">
                <strong>Nowe produkty do utworzenia:</strong>
                {{ validationResults.new_products.length }}
              </div>
              <div
                class="mb-2"
                v-if="validationResults.missing_units.length > 0"
              >
                <strong>Brakujące jednostki miary:</strong>
                {{ validationResults.missing_units.join(", ") }}
              </div>
            </v-card-text>
          </v-card>
        </v-col>

        <v-col cols="9">
          <v-table id="loadedTable">
            <thead>
              <tr>
                <th v-for="el in table[0].length" :key="el">
                  <v-select
                    v-model="headerSelection[el - 1]"
                    :items="[
                      '',
                      'Nazwa',
                      'SKU',
                      'EAN',
                      'Ilość',
                      'jednostka',
                      'Cena',
                      'Waga (kg)',
                      'Długość (cm)',
                      'Szerokość (cm)',
                      'Wysokość (cm)',
                      'Informacje dodatkowe ',
                    ]"
                    outlined
                    @update:modelValue="makeHeader"
                  >
                  </v-select>
                </th>
              </tr>
            </thead>
            <tbody>
              <tr v-for="(item, ix) in table" :key="ix">
                <td v-for="(it, i) in item" :key="i">{{ it }}</td>
              </tr>
            </tbody>
          </v-table>
        </v-col>
      </v-row>
    </v-container>
  </div>
</template>

<script>
import * as XLSX from "xlsx";
import axios from "axios";
import _ from "lodash";
export default {
  name: "FulstorImportXLS",
  props: ["user"],
  data: () => ({
    loading: false,
    validating: false,
    creating: false,

    errorMessages: [],
    message: "",
    snackbar: false,

    files: null,
    table: [],
    header: [],
    headerSelection: [],
    IDWarehouse: null,
    warehouses: [],

    validationResults: null,
    documentCreated: null,
  }),

  mounted() {
    this.getWarehouse();
  },
  watch: {
    IDWarehouse() {
      this.validationResults = null;
      this.documentCreated = null;
    },
  },
  computed: {
    canValidate() {
      return (
        this.IDWarehouse && this.table.length > 1 && this.header.length > 0
      );
    },
    canCreateDocument() {
      return (
        this.validationResults &&
        this.validationResults.errors.length === 0 &&
        this.validationResults.status === "success"
      );
    },
  },
  methods: {
    canValidate() {
      return (
        this.IDWarehouse && this.table.length > 1 && this.header.length > 0
      );
    },
    canCreateDocument() {
      return (
        this.validationResults &&
        this.validationResults.errors.length === 0 &&
        this.validationResults.status === "success"
      );
    },
  },
  methods: {
    makeJson() {
      if (this.table.length) {
        const result = [];
        for (let i = 1; i < this.table.length; i++) {
          const row = {};
          for (let j = 0; j < this.header.length; j++) {
            if (this.header[j]) {
              row[this.header[j]] = this.table[i][j];
            }
          }
          result.push(row);
        }
        console.log(result);
        this.message = "JSON created in console";
        this.snackbar = true;
      }
    },
    async validateProducts() {
      if (!this.canValidate) {
        this.message =
          "Wybierz magazyn i wczytaj plik Excel z prawidłowymi nagłówkami";
        this.snackbar = true;
        return;
      }

      this.validating = true;
      this.validationResults = null;

      try {
        try {
        const products = this.getProductsFromTable();
        
        if (products.length === 0) {
          this.message = "Brak danych do walidacji";
          this.snackbar = true;
          return;
        }
        
        const response = await axios.post('/api/checkDMProducts', {
          IDWarehouse: this.IDWarehouse,
          products: products
        });

        if (response.data.status === 'success') {
          this.validationResults = response.data;
          this.message = "Walidacja zakończona pomyślnie";
        } else {
          this.message = response.data.message || "Błąd podczas walidacji";
        }
        
        this.snackbar = true;
      } catch (error) {
        console.error('Validation error:', error);
        let errorMessage = "Błąd podczas walidacji produktów";
        
        if (error.response && error.response.data && error.response.data.message) {
          errorMessage = error.response.data.message;
        } else if (error.message) {
          errorMessage += ": " + error.message;
        }
        
        this.message = errorMessage;
        this.snackbar = true;
      } finally {
        this.validating = false;
      }
    },
    async createDocument() {
      if (!this.canCreateDocument) {
        this.message = "Najpierw przeprowadź walidację bez błędów";
        this.snackbar = true;
        return;
      }

      this.creating = true;

      try {
        const products = this.getProductsFromTable();

        const response = await axios.post("/api/createDMDocument", {
          IDWarehouse: this.IDWarehouse,
          products: products,
          existing_products: this.validationResults.existing_products,
          new_products: this.validationResults.new_products,
          missing_units: this.validationResults.missing_units,
          user_id: this.user?.id || 1,
        });

        if (response.data.status === "success") {
          this.documentCreated = response.data;
          this.message = `Dokument DM ${response.data.document_number} został utworzony pomyślnie`;

          // Clear data after successful creation
          this.clear();
          this.validationResults = null;
        } else {
          this.message =
            response.data.message || "Błąd podczas tworzenia dokumentu";
        }

        this.snackbar = true;
      } catch (error) {
        console.error("Document creation error:", error);
        this.message = "Błąd podczas tworzenia dokumentu DM";
        this.snackbar = true;
      } finally {
        this.creating = false;
      }
    },
    getProductsFromTable() {
      const products = [];
      for (let i = 1; i < this.table.length; i++) {
        const row = {};
        for (let j = 0; j < this.header.length; j++) {
          if (this.header[j]) {
            row[this.header[j]] = this.table[i][j];
          }
        }
        products.push(row);
      }
      return products;
    },
    cleanTableData(table) {
      return table.map(row => {
        return row.map(cell => {
          if (typeof cell === 'string') {
            // Remove null bytes and other problematic characters
            return cell.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '').trim();
          }
          return cell;
        });
      });
    },
    clear() {
      this.files = null;
      this.table = [];
      this.header = [];
      this.headerSelection = [];
      this.validationResults = null;
      this.documentCreated = null;
    },
    getWarehouse() {
      const vm = this;
      axios
        .get("/api/getWarehouse")
        .then((res) => {
          if (res.status == 200) {
            vm.warehouses = res.data;
            vm.warehouses = vm.warehouses.map((w) => {
              w.koef = parseFloat(w.koef);
              return w;
            });
          }
        })
        .catch((error) => console.log(error));
    },
    getheader() {
      this.header = [...this.headerSelection];
      console.log("Header:", this.header);
    },
    makeHeader() {
      this.getheader();
    },
    onFileChange(event) {
      // event - объект события change
      const fileList = event && event.target ? event.target.files : null;
      let file = fileList && fileList.length ? fileList[0] : null;
      if (!file) return;

      // Проверяем расширение файла
      const allowedExtensions = [".xlsx", ".xls"];
      const fileName = file.name ? file.name.toLowerCase() : "";
      const hasValidExtension = allowedExtensions.some((ext) =>
        fileName.endsWith(ext)
      );

      // Проверяем MIME-тип файла
      const allowedTypes = [
        "application/vnd.ms-excel",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
      ];
      const hasValidType = allowedTypes.includes(file.type);

      if (hasValidExtension || hasValidType) {
        this.files = file; // сохраняем только сам файл
        this.createInput(file);
      } else {
        this.files = null;
        this.message =
          "Nieprawidłowy format pliku. Pobierz plik Excel (.xlsx lub .xls)";
        this.snackbar = true;
      }
    },
    createInput(f) {
      let vm = this;
      var reader = new FileReader();

      reader.onload = function (e) {
        try {
          var data = e.target.result,
            fixedData = vm.fixdata(data),
            workbook = XLSX.read(btoa(fixedData), { 
              type: "base64",
              codepage: 65001, // UTF-8
              cellText: false,
              cellDates: true
            }),
            firstSheetName = workbook.SheetNames[0],
            worksheet = workbook.Sheets[firstSheetName];

          vm.loading = true;
          setTimeout(() => {
            try {
              vm.table = XLSX.utils.sheet_to_json(worksheet, { 
                header: 1,
                raw: false,
                defval: "",
                blankrows: false
              });
              
              // Clean the data from encoding issues
              vm.table = vm.cleanTableData(vm.table);
              
              vm.headerSelection = new Array(vm.table[0]?.length || 0).fill("");
              console.log("Loaded table data:", vm.table);
              console.log("Table length:", vm.table.length);

              if (vm.table.length === 0) {
                vm.message = "Plik Excel jest pusty lub nie zawiera danych";
                vm.snackbar = true;
              }
            } catch (error) {
              console.error("Error processing Excel file:", error);
              vm.message = "Błąd podczas przetwarzania pliku Excel: " + error.message;
              vm.snackbar = true;
              vm.table = [];
              vm.headerSelection = [];
            }
            vm.loading = false;
          }, 100);
        } catch (error) {
          console.error("Error reading Excel file:", error);
          vm.message = "Błąd podczas odczytu pliku Excel: " + error.message;
          vm.snackbar = true;
          vm.loading = false;
        }
      };
      
      reader.onerror = function(error) {
        console.error("FileReader error:", error);
        vm.message = "Błąd podczas wczytywania pliku";
        vm.snackbar = true;
        vm.loading = false;
      };
      
      reader.readAsArrayBuffer(f);
    },
    fixdata(data) {
      var o = "",
        l = 0,
        w = 10240;
      for (; l < data.byteLength / w; ++l)
        o += String.fromCharCode.apply(
          null,
          new Uint8Array(data.slice(l * w, l * w + w))
        );
      o += String.fromCharCode.apply(null, new Uint8Array(data.slice(l * w)));
      return o;
    }
  }
};
</script>

<style >
#inspire #importXLS .v-text-field__details {
  display: initial;
}
#loadedTable .v-data-table__wrapper {
  overflow: auto;
  height: 80vh;
}
.text-red {
  color: red;
}
.text-orange {
  color: orange;
}
.d-flex {
  display: flex;
}
.gap-2 {
  gap: 8px;
}
</style>
